<!DOCTYPE html>
<html>
<head>
    <title>Gesture-Controlled 3D Particle System</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* Basic styling to make the 3D canvas fill the screen */
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000000;
            font-family: Arial, sans-serif;
            color: #ffffff;
        }
        canvas { 
            display: block; 
        }
        /* Hide the raw webcam feed but keep it available for MediaPipe */
        #webcam-video { 
            display: none; 
        } 
        #controls-display {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            z-index: 100;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <video id="webcam-video" autoplay playsinline></video>

    <div id="controls-display">
        <h3>✨ Particle Controls</h3>
        <p><strong>Expansion (Pinch):</strong> <span id="display-expansion">0%</span></p>
        <p><strong>Color (X-Pos):</strong> <span id="display-hue">Red</span></p>
        <p><strong>Template (Fist -> Open):</strong> <span id="display-template">Default</span></p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js"></script>

    <script id="vertex-shader" type="x-shader/x-vertex">
        uniform float uTime;
        uniform float uExpansionFactor;
        uniform float uColorHue;
        uniform float uTemplateIndex;
        uniform float uRandomSeed;

        attribute vec3 position;
        attribute vec3 aInitialOffset;
        attribute vec3 color;

        varying vec3 vColor;

        // Helper: Converts HSL (Hue, Saturation, Lightness) to RGB
        vec3 hsl2rgb(vec3 c) {
            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
            vec4 p = mix(vec4(c.xyz, 1.0), vec4(c.yzx, 1.0), step(K.w, c.x));
            return c.z * (1.0 + c.y * (p.xyz - K.xyz));
        }

        // --- Core Template Functions ---
        vec3 templateHeart(vec3 p) {
            float angle = atan(p.y, p.x);
            float radius = length(p.xy) + aInitialOffset.z * 0.1; 
            
            // Basic cardioid shape function
            float heart_radius = 0.5 * (1.0 - sin(angle));
            
            // Interpolate towards the heart shape
            p.x = mix(p.x, cos(angle) * heart_radius * 2.0, 0.7);
            p.y = mix(p.y, sin(angle) * heart_radius * 2.0, 0.7);
            return p;
        }

        vec3 templateSaturn(vec3 p) {
            float distance = length(p.xyz);
            float ringRadius = 1.5;
            float thickness = 0.5 + abs(aInitialOffset.x) * 0.5;

            // Simple ring shaping
            if (abs(distance - ringRadius) < thickness) {
                p.y *= 0.1; // Flatten on the Y axis
            }
            return p;
        }
        
        vec3 templateFireworks(vec3 p) {
            float life = fract(aInitialOffset.y + uTime * 0.2); // Particle lifetime 0 to 1
            float phase = life * 6.28; // 0 to 2*PI
            
            // Explosion position based on lifetime
            p.x += cos(phase * 10.0 + aInitialOffset.x * 10.0) * life * 2.0;
            p.y += sin(phase * 10.0 + aInitialOffset.y * 10.0) * life * 2.0 - life * 5.0; // Gravity effect
            p.z += cos(phase * 10.0 + aInitialOffset.z * 10.0) * life * 2.0;
            
            return p;
        }
        
        // --- Main Position Calculation ---
        vec3 getParticlePosition(vec3 p) {
            // Apply base animation (subtle breathing/movement)
            p += sin(uTime * 0.5 + aInitialOffset * uRandomSeed) * 0.1;
            
            // 1. Template Switching: Interpolate between templates
            // We use step functions for discrete switching based on uTemplateIndex
            if (uTemplateIndex < 0.5) {
                // Template 0: Sphere/Explosion (Default) - simply use base P
            } else if (uTemplateIndex < 1.5) {
                // Template 1: Heart
                p = templateHeart(p);
            } else if (uTemplateIndex < 2.5) {
                // Template 2: Saturn
                p = templateSaturn(p);
            } else {
                // Template 3: Fireworks
                p = templateFireworks(p);
            }

            // 2. Expansion/Spread (Controlled by Hand Gesture)
            p *= (1.0 + uExpansionFactor * 3.0); 
            
            return p;
        }

        void main() {
            // Calculate the dynamic position
            vec3 newPosition = getParticlePosition(position);

            // Calculate dynamic color
            float saturation = 0.8; 
            float lightness = 0.6;  
            vColor = hsl2rgb(vec3(uColorHue, saturation, lightness));

            gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
            
            // Point size scales with expansion and distance from camera
            float pointSize = (1.0 + uExpansionFactor * 3.0) * (50.0 / gl_Position.w);
            gl_PointSize = pointSize;
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        varying vec3 vColor;

        void main() {
            // Radial gradient for a soft glow/circle effect
            vec2 center = gl_PointCoord - 0.5;
            float r = length(center);
            
            float alpha = 1.0 - smoothstep(0.3, 0.5, r); // Fade out towards the edge
            
            gl_FragColor = vec4(vColor, alpha * 0.9);
        }
    </script>

    <script>
        // --- JAVASCRIPT LOGIC ---

        // Global state for particle controls
        const particleControls = {
            expansionFactor: 0.0, // 0.0 to 1.0 (Pinch distance)
            colorHue: 0.0,       // 0.0 to 1.0 (Hand X-position)
            templateIndex: 0,    // Current particle template
            wasClosed: false     // State tracking for template switch gesture
        };
        const particleTemplates = ['Default (Sphere)', 'Hearts', 'Saturn Rings', 'Fireworks'];
        let currentTemplateIndex = 0;

        // UI elements for feedback
        const uiExpansion = document.getElementById('display-expansion');
        const uiHue = document.getElementById('display-hue');
        const uiTemplate = document.getElementById('display-template');

        // --- PART 1: THREE.JS SETUP ---

        const scene = new THREE.Scene();
        const camera3D = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera3D.position.z = 5;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const particleCount = 70000;
        const particleGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const initialOffsets = new Float32Array(particleCount * 3);

        // Initialize particle data
        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            
            // Initial position (Start point for the shape calculation)
            // Use spherical distribution
            const r = Math.pow(Math.random(), 0.5) * 4; 
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(Math.random() * 2 - 1);
            positions[i3 + 0] = r * Math.sin(phi) * Math.cos(theta);
            positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i3 + 2] = r * Math.cos(phi);

            // Initial random offset (for individual animation/template variations)
            initialOffsets[i3 + 0] = Math.random() * 2 - 1;
            initialOffsets[i3 + 1] = Math.random() * 2 - 1;
            initialOffsets[i3 + 2] = Math.random() * 2 - 1;
        }

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particleGeometry.setAttribute('aInitialOffset', new THREE.BufferAttribute(initialOffsets, 3));

        // Uniforms: Variables passed to the shader
        const uniforms = {
            uTime: { value: 0.0 },
            uExpansionFactor: { value: 0.0 },
            uColorHue: { value: 0.0 },
            uTemplateIndex: { value: 0 },
            uRandomSeed: { value: Math.random() * 100 }
        };

        const particleMaterial = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: document.getElementById('vertex-shader').textContent,
            fragmentShader: document.getElementById('fragment-shader').textContent,
            blending: THREE.AdditiveBlending, // Good for glow effects
            depthTest: false,
            transparent: true,
            vertexColors: false // Color is computed in the shader
        });

        const points = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(points);

        // --- PART 2: MEDIAPIPE HAND TRACKING SETUP ---
        const videoElement = document.getElementById('webcam-video');
        const hands = new Hands({locateFile: (file) => {
          return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`;
        }});

        hands.setOptions({
          maxNumHands: 1,
          modelComplexity: 1,
          minDetectionConfidence: 0.8,
          minTrackingConfidence: 0.7
        });

        hands.onResults(onResults);

        // Setup the camera stream
        const camera = new Camera(videoElement, {
          onFrame: async () => {
            await hands.send({image: videoElement});
          },
          width: 640,
          height: 480
        });
        
        // Start the camera. This requires user interaction (e.g., clicking on the page) 
        // in some browsers, but CameraUtils handles the stream setup.
        camera.start(); 


        // Helper function to calculate 3D distance between two normalized landmarks
        const dist = (p1, p2) => Math.sqrt(
            Math.pow(p1.x - p2.x, 2) + 
            Math.pow(p1.y - p2.y, 2) + 
            Math.pow(p1.z - p2.z, 2)
        );

        function onResults(results) {
            if (results.multiHandLandmarks.length > 0) {
                const hand = results.multiHandLandmarks[0];
                
                // 1. Expansion/Color Control (Pinch Gesture)
                const thumbTip = hand[4]; // Thumb Tip
                const indexTip = hand[8]; // Index Tip
                const pinchDistance = dist(thumbTip, indexTip); 

                // Map the normalized pinch distance to the 0.0-1.0 expansion factor
                // (Tune these min/max values based on your hand size/camera distance)
                const minPinchDist = 0.03;
                const maxPinchDist = 0.35;
                
                // smoothstep maps the value within the range [min, max] to [1, 0] (inverse for pinch)
                let expansion = THREE.MathUtils.smoothstep(pinchDistance, maxPinchDist, minPinchDist);
                particleControls.expansionFactor = Math.min(1.0, Math.max(0.0, expansion));
                
                // Use the Index Finger's normalized X position for color hue
                // Map X from 0.0 (left) to 1.0 (right)
                particleControls.colorHue = 1.0 - indexTip.x; // Inverting X for a more natural feel

                // 2. Template Switching (Fist Gesture)
                // Check if index, middle, ring, and pinky tips are close to their MCP joints
                const isFistClosed = (
                    dist(hand[8], hand[5]) < 0.15 &&  // Index tip to Index MCP
                    dist(hand[12], hand[9]) < 0.15 && // Middle tip to Middle MCP
                    dist(hand[16], hand[13]) < 0.15 &&// Ring tip to Ring MCP
                    dist(hand[20], hand[17]) < 0.15   // Pinky tip to Pinky MCP
                );

                // Simple state machine: trigger when the hand *opens* after being closed
                if (isFistClosed) {
                    particleControls.wasClosed = true;
                } else if (!isFistClosed && particleControls.wasClosed) {
                    particleControls.wasClosed = false;
                    currentTemplateIndex = (currentTemplateIndex + 1) % particleTemplates.length;
                    particleControls.templateIndex = currentTemplateIndex;
                }
            }
        }


        // --- PART 3: ANIMATION LOOP ---

        function animate(time) {
            requestAnimationFrame(animate);
            
            // Smoothly update Uniforms from Gesture Data (Lerp for smooth transition)
            uniforms.uTime.value = time * 0.001;
            uniforms.uExpansionFactor.value = THREE.MathUtils.lerp(uniforms.uExpansionFactor.value, particleControls.expansionFactor, 0.15);
            uniforms.uColorHue.value = THREE.MathUtils.lerp(uniforms.uColorHue.value, particleControls.colorHue, 0.15);
            uniforms.uTemplateIndex.value = particleControls.templateIndex;

            // Update UI Feedback
            uiExpansion.textContent = `${Math.round(uniforms.uExpansionFactor.value * 100)}%`;
            uiHue.textContent = `${(uniforms.uColorHue.value * 360).toFixed(0)}°`;
            uiTemplate.textContent = particleTemplates[uniforms.uTemplateIndex.value];

            // Subtle rotation for 3D effect
            points.rotation.y = uniforms.uTime.value * 0.05;

            renderer.render(scene, camera3D);
        }

        // Start the animation loop
        animate(0);

        // Handle window resizing
        window.addEventListener('resize', () => {
            camera3D.aspect = window.innerWidth / window.innerHeight;
            camera3D.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
